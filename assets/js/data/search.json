[ { "title": "Run Android apps in a debugger without root", "url": "/posts/Debugger-Android-no-root/", "categories": "", "tags": "", "date": "2025-04-11 14:00:00 +0200", "snippet": "IntroductionIn this article, I will explain how to run a compiled third-party Android app in a debugger like lldb on a non-rooted device.PrerequisitesInstall Android Studio and download the SDK and NDK.I won’t go into much details about how to do this.You can check that the installation was successfull if : you can run adb you have the NDK installed (on macOS with default settings, it will be in /Users/$(whoami)/Library/Android/sdk/ndk) you can find lldb-server in $NDK-PATH/*/toolchains/llvm/prebuilt/*/lib/clang/*/lib/linux/aarch64/lldb-serverMake sure your .apk is debuggableYou can follow this tutorial to make a release .apk debuggableA few words before continuingBefore going any further, I want to explain the challenges that we are facing when trying to run our debugger on a non-rooted device.NB : I am running this experiment on a Meta Quest, and these devices have special (annoying) read-write issues that may not happen with other Android devices.On Meta Quest, we can sideload our lldb-server to a writable place, like /sdcard/Documents. Let’s try this :$ adb push lldb-server /sdcard/Documents/lldb-server$ adb shell /sdcard/Documents/lldb-server/system/bin/sh: /sdcard/Documents/lldb-server: can&#39;t execute: Permission denied$ adb shell ls -l /sdcard/Documents/lldb-server-rw-rw---- 1 root everybody 49731928 2025-04-11 20:16 /sdcard/Documents/lldb-server$ adb shell chmod 777 /sdcard/Documents/lldb-server$ adb shell ls -l /sdcard/Documents/lldb-server-rw-rw---- 1 root everybody 49731928 2025-04-11 20:16 /sdcard/Documents/lldb-serverIndeed, we do not have execution rights. And we can’t add them neither with chmod.To be able to debug our app, the debugger needs to run with the same level of priviledge than the app. So let’s try :$ adb shell run-as com.bundle.identifier /sdcard/Documents/lldb-serverrun-as: exec failed for /sdcard/Documents/lldb-server: Permission denied$ adb shell run-as com.bundle.identifier ls /sdcard/Documentsls: /sdcard/Documents: Permission deniedSee, the com.bundle.identifier user does not even have right to read /sdcard/Documents.But then, where can our app read/write/execute ?$ adb shell run-as com.bundle.identifier pwd/data/user/0/com.bundle.identifier$ adb shell run-as com.bundle.identifier touch test$ adb shell run-as com.bundle.identifier chmod 777 test$ adb shell run-as com.bundle.identifier ls -l test-rwxrwxrwx 1 u0_a169 u0_a169 0 2025-04-11 20:18 test$ adb shell run-as com.bundle.identifier rm testSo, sideloading our lldb-server to this location should work, right ? Well, yes, except we can’t :$ adb push lldb-server /data/user/0/com.bundle.identifier/lldb-serveradb: error: stat failed when trying to push to /data/user/0/com.bundle.identifier: Permission deniedWe can solve this issue, using piping :$ tar cf - lldb-server | adb shell &#39;run-as com.bundle.identifier tar xf - &#39;Now, we can finally execute lldb-server :$ adb shell run-as com.bundle.identifier ./lldb-serverUsage: ./lldb-server v[ersion] ./lldb-server g[dbserver] [options] ./lldb-server p[latform] [options]Invoke subcommand for additional helpDebugging the appNow, it’s time to debug our app.Let’s launch lldb-server :$ adb shell run-as com.bundle.identifier ./lldb-server platform --listen &quot;*:10086&quot; --serverForward the port with adb :$ adb forward tcp:10086 tcp:10086Start the app (you can also launch it directly via your graphical interface on the device) :$ adb shell am start -n com.bundle.identifier/com.your.activityGet the app’s PID :$ adb shell ps -A | grep com.bundle.identifierGet your device ID :$ adb devicesLaunch lldb on your host:$ lldb(lldb) platform select remote-android(lldb) platform connect connect://YOUR-DEVICE-ID:10086(lldb) process attach --pid XXXX(Optional) Ignore signals SIGXCPU and SIGPWR :(lldb) process handle SIGXCPU -n false -p true -s false(lldb) process handle SIGPWR -n false -p true -s falseSource : StackOverflow" }, { "title": "Frida Gadget/Objection on iOS 18", "url": "/posts/Frida-gadget-on-iOS-18/", "categories": "", "tags": "", "date": "2025-03-30 18:00:00 +0200", "snippet": "IntroductionRunning Frida gadget on (jailed) iOS 18 can be suprisingly more difficult that expected.In this article, I am providing a full method to get Frida Gadget running on such a device.Prerequisites a device running iOS 18 a Mac Xcode (can be Xcode 15+) Sideloadly ObjectionSteps1) Get a decrypted IPAYou can get a decrypted IPA for your app at armconverter.com/decryptedappstore.2) Get a signing identity and an embedded.mobileprovisionIn Xcode, create a sample app for iOS and run it on your device. You can view your signing identity with: % security find-identity -p codesigning -v 1) 85719B2FB2XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX &quot;Apple Development: xxxxxxx@xyz.com (YYYXXXXXXX)&quot; 1 valid identities found You can extract the embedded.mobileprovision from the build result from Xcode (for example /Users/xxx/Library/Developer/Xcode/DerivedData/SampleApp-xxxxxxxxxxxxxxxx/Build/Products/Debug-iphoneos/SampleApp.app/embedded.mobileprovision)You can get more details on the Objection GitHub page.3) Patch the appFollow the instructions on Objection wiki for iOS to prepare a patched .ipa.This should give you a fresh .ipa like this:4) Install the appUnfortunately, as of iOS 17+, we can no longer use ios-deploy to launch apps. So we’ll not use this tool at all.Instead, we can just use Sideloadly !You can take note of the bundle identifier here, and change it if needed.5) Launch the appIf you just try to launch the app by tapping its icon on the home screen, it will just crash.Run this command to start the app paused:xcrun devicectl device process launch --device 00008120-&amp;lt;identifier&amp;gt; --start-stopped com.bundle.identifierYou can get your device identifier from Xcode &amp;gt; Window &amp;gt; Devices and Simulators.The app should launch and freeze.Next go to Xcode &amp;gt; Debug &amp;gt; Attach to process and find your app.You should see Frida: Listening on 127.0.0.1 TCP port 27042 on the console.6) Connect to FridaWe need to use the networked mode.On a terminal window, run:pymobiledevice3 usbmux forward 27042 27042and in another:objection -N -h 127.0.0.1 -p 27042 exploreCongrats ! 🥳 You are connected !" }, { "title": "Cross-compiling radare2 for armhf and Buildroot", "url": "/posts/Cross-compiling-radare2-for-armhf-and-Buildroot/", "categories": "", "tags": "", "date": "2025-02-16 14:00:00 +0100", "snippet": "IntroductionIn this article, we will learn how to compile radare2 for armhf using Buildroot’s toolchain (note that this can be adapted to any other cross-toolchain you have, either you got it from your package manager, or with Crosstool-NG).I assume you are familiar with Buildroot and already know how to use it to build a Linux system.StepsFirst, clone the radare2 repo:$ git clone https://github.com/radareorg/radare2Then, build a toolchain using Buildroot:# assuming Buildroot is ready in its dedicated folder$ cd ~/buildroot$ make qemu_arm_vexpress_defconfig$ make menuconfig$ make toolchainThis will give you a full cross-toolchain in buildroot/output/host/.The sysroot will be in buildroot/output/host/arm-buildroot-linux-gnueabi*/sysroot.Next, create an overlay, i.e. a folder that will receive additional files that Buildroot will copy to its rootfs at the end of the build so that they are available to the target system.$ mkdir ~/buildroot/overlayNow, configure radare2 to use Buildroot’s cross-compiler, and to output it to our overlay:$ cd ~/radare2$ CC=$HOME/buildroot/output/host/bin/arm-buildroot-linux-gnueabihf-gcc \\ CFLAGS=-I$HOME/output/host/include LDFLAGS=-L$HOME/buildroot/output/host/lib \\ ./configure --prefix=$HOME/buildroot/overlay/usr/local/r2 \\ --target=armhf-buildroot-linux --host=armhf-buildroot-linux$ make -j 8$ make installSince we installed r2 to /usr/local/r2, its binaries and libs won’t be found be default, so we need to edit LD_LIBRARY_PATH and PATH of our new system.First, we can alter the PATH by setting the BR2_SYSTEM_DEFAULT_PATH to include our r2 folder.As for LD_LIBRARY_PATH, we can set it by creating /etc/profile:$ cd ~/buildroot/overlay$ mkdir etc$ cat &quot;export LD_LIBRARY_PATH=/usr/local/r2/lib:$LD_LIBRARY_PATH&quot; &amp;gt;&amp;gt; overlay/etc/profileYou can now build your rootfs with Buildroot, and do not forget to add the overlay to your build by settings BR2_ROOTFS_OVERLAY to $HOME/buildroot/overlay.Then build:$ cd ~/buildroot$ make menuconfig# set BR2_ROOTFS_OVERLAY and BR2_SYSTEM_DEFAULT_PATH, save and exit$ makeConclusionNow your system has radare2 installed!Welcome to Buildrootbuildroot login:$ r2Usage: r2 [-ACdfjLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-c cmd] [-s addr] [-B baddr] [-m maddr] [-i script] [-e k=v] file|pid|-|--|=Useful links https://book.rada.re/install/download.html https://github.com/radareorg/radare2/blob/master/doc/cross-compile.md" }, { "title": "Enabling framebuffer on qemu_arm_versatile and Buildroot", "url": "/posts/Enabling-framebuffer-on-qemu_arm_versatile-and-buildroot/", "categories": "", "tags": "", "date": "2025-02-09 16:00:00 +0100", "snippet": "IntroductionWhen using the default Buildroot target qemu_arm_versatile, no display is enabled: That’s sad and disappointingIn this tutorial, we will learn how to get the kernel to recognize the display, and setup the framebuffer, so as to display beautiful images like this one: That’s more colorful (running fb-test)Setting up the no-screen VMFirst, let’s create a simple system based on the template Buildroot provides for Qemu’s versatilepb.Get and extract Buildroot (2024.02.10 at the time of writing):$ wget http://buildroot.org/downloads/buildroot-2024.02.10.tar.xz$ xz -d buildroot-2024.02.10.tar.xz$ tar -xvf buildroot-2024.02.10.tar$ rm buildroot-2024.02.10.tar.xz$ cd buildroot-2024.02.10Now, let’s use the defconfig for our target:$ make qemu_arm_versatile_defconfig $ makeOnce the build is done, we can boot it:$ output/images/start-qemu.sh...Welcome to Buildrootbuildroot login: You can login with username root, and notice how no framebuffer device is available:# ls /dev | grep fb0#Enabling the displayManuallyWe need to enable kernel config options to have the kernel recognize the embedded PL110 LCD controller.Run:$ make linux-menuconfigOnce in the menu, enable the following options (that Buildroot’s default qemu_arm_versatile_defconfig does not enable):Device Drivers -&amp;gt; Graphics support -&amp;gt; Direct Rendering Manager (XFree86 4.1.0 and higher DRI support) [y] -&amp;gt; Display Interface Bridges -&amp;gt; Display connector support [y] -&amp;gt; Display Panels -&amp;gt; ARM Versatile panel driver [y] -&amp;gt; support for simple Embedded DisplayPort panels [y] -&amp;gt; support for simple panels (other than eDP ones) -&amp;gt; DRM Support for PL111 CLCD Controller -&amp;gt; Console display driver support -&amp;gt; Framebuffer Console support [y] -&amp;gt; Map the console to the primary display deviceAlternatively, you can search for these options and enable them:DRM [y]DRM_DISPLAY_CONNECTOR [y]DRM_PANEL_ARM_VERSATILE [y]DRM_PANEL_EDP [y]DRM_PANEL_SIMPLE [y]DRM_PL111 [y]CONFIG_FRAMEBUFFER_CONSOLE [y]CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY [y]Save, exit and build.$ make linux # if you only want to build the kernel$ make # to build everythingWarning! Your modifications will be lost when the build folder is cleaned!That’s because Buildroot uses output/build/linux-x.x.x/.config to configure linux, and this folder is deleted by make clean.AutomaticallyYou can use this config patch that automatically enables these options.We can tell Buildroot to apply these patches on top of its configuration before building the kernel.You can enable it in Buildroot by adding its path to the BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES variable in Buildroot.ConclusionThe system now boots with a working display ! Tux!Useful links https://lukaszgemborowski.github.io/articles/minimalistic-linux-system-on-qemu-arm.html https://www.qemu.org/docs/master/system/arm/versatile.html https://github.com/buildroot/buildroot/blob/master/board/qemu/arm-versatile/linux.fragment" }, { "title": "Fulling theming macOS Big Sur", "url": "/posts/macOS-theming/", "categories": "", "tags": "", "date": "2022-09-05 20:50:00 +0200", "snippet": "IntroductionEveryone with a jailbroken has probably already themed their iPhone, right ?Well, actually, you don’t even need to be jailbroken to enjoy alternative icons on iOS, but theming has been a long tradition in the jailbreak community. Felicity Pro and Dotto+ on iPhone 11So, why not doing the same on macOS ? Well, mostly because, just like iOS, it’s not possible on stock. While you can indeed change thrid-party apps icons easily, more advanced theming (like system apps icons or notification badges) cannot be customized on stock.In this article, I’m going to describe the different techniques one can use to achieve full theming on macOS Big Sur. This may work as well on Monterey (and Ventura ?) but I haven’t tested it yet.Here is a little preview of what we will be achieving :Where to get icons for macOS ?If you don’t want to make custom icons yourself, you can visit macosicons.com. They have thousands of incredible icons and you’ll most probably find one you like.If you can’t find what you’re looking for, you’ll have to make icons yourself. To edit a picture online, you can use lunapic.com to edit images, then turn them into .icns files using Image2icon available for free on the Mac AppStore.Disabling SIP and SSVTo achieve our goals, we have to disable SIP (System Integrity Protection) and SSV (Signed System Volume). These are system protections built in macOS and disabling them may alter your system security and leave your Mac more vulnerable to malware. Please do NOT do this is you don’t know what you’re doing !I’m not responsible for any problem that may result from doing this.Boot into Recovery Mode, open the terminal and run :\\csrutil disablecsrutil authenticated-root disableThen reboot to macOS.If your Mac fails to boot (there is no real reason this can happen if you didn’t mess anything, but that happened to me once), just reinstall macOS. You won’t lose your data if you don’t erase your main disk. As usual, having a backup is the safest way to prevent data loss (which can always happen…).Also note that enabling verbose boot can help diagnosing issues during boot if you encounter any.Once in macOS, check if everything is disabled correctly :run csrutil status, you should see it’s disabled.Same, run csrutil authenticated-root status, it should be disabled too.Changing third-party apps icons Editing third-party apps icons does NOT require SIP and/or SSV to be disabled, so you can keep them on if you’re just planning to theme third party apps.Go to Finder -&amp;gt; Applications and select the app you want to theme.Then, you can either press Command + I or go right-click -&amp;gt; Get Info.Finally, drag and drop your new icon into the icon slot :Drop hereThis is trivial and has already been discussed countless times online, so I won’t go into any further details here.Changing System apps iconsThis is normally not possible because the System volume is mounted as read-only. Unfortunately, it’s not possible to remount it directly as read-write (it used to be possible on Catalina and earlier) and to do it, it’s necessary to disable SIP and SSV, as we did earlier.Which volume should we mount ?Open Disk Utility and look for Macintosh HD. Note down the device identifier (here, it is /dev/disk3s1). It’s normal if you don’t have the “System snapshot mounted” message. It appears for me because I’ve already done all the steps described further down the article.Then, create a mountpoint :mkdir /tmp/mountand finally, mount your disk heresudo mount -w -t apfs /your/identifier /tmp/mountEditing the iconsThen we can navigate to /tmp/mount/System/Applications/ where System apps are stored. Now, this location is readable and writable.You may now change any icon you want using the method decsribed earlier for third party apps (using drag and drop).Then, I strongly recommend you test your edits by performing the steps described below in the section “Saving changes”.Modifying notification badgesDo you seriously find these red notification badges pretty ?Sorry, but that’s uglyI’m ususally a huge fan of “stock” visuals, but these huge red dots look really ugly, especially if you’ve opted, like me, for a certain color scheme. These badges can look horrible.So, let’s change them ! More precisely, we’re gonna change the badges color.With your System volume mounted as read-write (see the “Changing System apps icons” section above on how to achieve this), navigate to /tmp/mount/System/Library/CoreServices/Dock.app/Contents/Resources.Once you’re there, find 2 files called statuslabel.png and statuslabel@2.png.Just backup them and replace them with custom icons (make sure to keep the same resolution and the exact same filename). Save your changes (see section below), reboot and you’ll see nice badges with the color that suits best to your theme :There is a badge on the Reminders appModifying the Finder iconSame as before, mount your System volume as read-write and navigate to /tmp/mount/System/Library/CoreServices/Dock.app/Contents/Resources.Then, just replace finder.png and finder@2.png by yours.Again, don’t forget to backup the original files, save your changes and reboot.Modiying the calendar iconBecause yes, there is a big quirck with the Calendar app : its icon is generated at runtime, because it changes every day…Trying any of the above methods will not work (you can try yourself, but I already did it for you…).You could force the system to use a static icon (editing the Calendar app’s Info.plist) but the icon won’t change over time, which is not satisfying.So, we have to understand how the Calendar app changes its icon. Reversing the executable in Hopper was useless, same when reversing its Docktile plugin (/System/Applications/Calendar.app/Contents/Resources/Calendar.docktileplugin).Searching online suggests the existence of an App-empty.icns file that we could replace to achieve what we want.However, while this has already been discussed here, this file can longer be found where we expect it to be.Fortunately, the terminal can help us, and running sudo find / -name &quot;App-empty.icns&quot; shows interesting results :Let’s navigate to this path, but using our read-write permissions to be able to edit the file !So, we’ll go /tmp/mount/System/Library/PrivateFrameworks/CalendarUIKit.framework/Versions/A/Resources/Once there, you can backup and replace the App-empty.icns file !Once again, save your changes and reboot. The calendar icon will have changed.Cool, isn’t it ?Saving changesWe now have to make a new snapshot with your last changes and tell the system to use this snapshot to boot.Skipping this step will result in all your changes being lost.sudo bless --folder /tmp/mount/System/Library/CoreServices --bootefi --create-snapshotThen, we have to flush the icon cache, and force the system to regenerate a new one.sudo rm -rfv /Library/Caches/com.apple.iconservices.store &amp;gt; /dev/null 2&amp;gt;&amp;amp;1sudo find /private/var/folders/ -name com.apple.dock.iconcache -exec rm -rf {} \\; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1sudo find /private/var/folders/ -name com.apple.iconservices -exec rm -rf {} \\; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1Finally, unmount the disksudo umount -f /tmp/mountand reboot !You should see your changes saved and in action !Congratulations ! 🎉" }, { "title": "Verbose restore a 64 bits iPhone with checkm8", "url": "/posts/verbose-restore-64-bits/", "categories": "", "tags": "", "date": "2022-05-07 14:00:00 +0200", "snippet": "IntroductionIn this post, you’ll learn how to perform a verbose restore on a 64 bits iPhone using checkm8. While this should work on 32 bits devices too, I didn’t have time to try it out yet. I will update these instructions or make a new blogpost once I have done it on such a device.Why do you want to do this ? Maybe because you are curious and wonder what’s happening behind the scenes. For sure, idevicerestore provides a interesting log for you to read, but you could actually get much more than this simple log. When trying to dualboot an iPhone, I have trouble with the apfs_invert() method, and I thought comparing with a normal restore would help me diagnosing and hopefully solving my issues. Although the restore log can be accessed via serial output, it requires a DCSD cable and, even if such a cable only costs around 30$, I didn’t have any DCSD cable to use. So, let’s use a free method until buying a DCSD cable !Where to start ?@nyan_satan wrote a simple tutorial which you can find here decribing how to patch graphical routines. While this is definitely a great starting point, we also have to load our patch files, and this is what this tutorial is all about.The iOS restore process I am not an iOS expert, and what I’m saying might be wrong. Read it at your own risk. The following explanations are based on what I know and have understood from this project. I can’t guarantee it’s 100% (or even 1%) true. You’ll have been warned.Update or erase ?For the sake of this demo, we’ll proceed to a so-called “update” restore. With iOS devices, there are 2 restore fashions : “update” and “erase”.“Erase” restores perform some more operations on the disk (they wipe user data), and unfortunately I’ve not been able to perform such restores with UI routines disabled. On the other hand, “update” restore seems more cooperative, so that’s the restore style we’ll use.What happens during a restore ?We’ll start with a device placed in recovery mode.At this stage, iBSS and iBEC are already loaded and the device is waiting for the next boot images, including (but not limited to) kernelcache, a ramdisk and its associated trustcache, devicetree, etc.But here, we don’t have to care that much about what has to be sent, because idevicerestore already sends all the necessary files for us in the correct order.Our role “only” boils down to giving idevicerestore a valid IPSW file to work with.This sounds simple, but since we are patching things out, we’re breaking the chain of trust at some point, and restore will thus fail if we don’t do anything.What do we have to patch ?During a restore, the restore software (either iTunes, idevicerestore, futurerestore or whatever) sends a ramdisk, among other files. An IPSW contains 2 ramdisks, one for each restore type (their exact name can be found on The iPhone Wiki, in the Firmware Keys section).Inside the ramdisks, at path /usr/local/bin is a Mach-O executable which effectively performs the restore operations on the device side (the PC also plays its role, but the iPhone’s restore code is located in this executable). For “erase” variants, this executable is called restored_external while in “update” variants, it’s called restored_update.This is the executable we need to patch : it’s responsible for performing the restore but also handles the UI part (displaying the Apple logo and the progress bar).Some more complicationsOf course, it would be too easy to just patch this executable, repack the IPSW and restore it, right ?That’s because, when patching restored_update, we altered its signature. Of course, we will fakesign it with ldid2 but the kernel, if unpatched, will reject this signature.So we need to patch the kernel (we’ll see how to do this later on). But patching the kernel alters its signature, so iBEC won’t load it. We thus need to patch both iBSS and iBEC and this brings us back to checkm8 !Patching signature validations if what will make everything possible. Since we are flashing patched iBSS and iBEC to our device, these images won’t be validated if SecureROM is not patched. In other words, after this restore, you’ll have to tether boot your device.However, this can be easily reverted by restoring a normal IPSW : this will flash valid boot images, which will be booted untethered.CreditsAs I mentionned earlier, I got the idea to do this project thanks to @nyan_satan’s blog post.I also followed @mcg29_’s dualboot guide for learning how to load a custom bootchain.RequirementsHere are the tools you need for this project (I recommend you copy the compiled executables to /usr/local/bin on your Mac to always have them in your path) : img4lib aka img4 by @xerub kairos by @dayt0n Kernel64Patcher by @Ralph0045 ldid2 (install it with brew install ldid2) asr64_patcher by @md idevicerestore (compile everything with this by @matteyeux)Before you beginIf you’re not really familiar with iOS boot/restore processes, I recommend you first do the following : Restore a normal IPSW with idevicerestore and read the log. Read the dualboot guide by @Ralph0045 and @Ralph0045 and try it yourself. Verbose boot your iPhone. It’s an absolutely basic thing you MUST master well. It’s trivial, but do it by hand, not with checkra1n :)The general idea Extract a release IPSW (the latest one, which can be restored without blobs). While it is theoretically possible to restore with futurerestore to an unsigned version, I didn’t try it yet and can’t confirm it works out of the box. Patch iBSS and iBEC to load custom images ; and replace them in the original IPSW. Patch the kernelcache to disable AMFI and replace it in the original IPSW. Extract the “update” ramdisk and locate restored_update. Patch UI routines in restored_update, restore its entitlements and fakesign it. Patch asr to force image validation. Pack back the ramdisk. Pack back the IPSW and restore it. You are free to organise the project’s folders as you wish, so be careful since your commands may vary from mine.Copy-pasting is never a good idea, and you won’t learn anything.As for me, I’ve created a restore folder for all the stuffs with inside, the stock IPSW extracted in a folder called stock, and the modded IPSW in a folder called modded.Patching iBSS and iBECIf you have already verbose booted your iPhone, this part should look familiar to you. I’m using the kbag method to decrypt iBSS and iBEC. Thanks to this, I don’t rely on keys from The iPhone Wiki.For iBSS (for example), first extract its kbagimg4 -i iBSS.*.RELEASE.im4p -bThe kbag is the first line in the output.Then, place your iPhone in DFU mode, exploit it with ./ipwndfu -p but don’t remove sigchecks yet ! Instead, run :./ipwndfu --decrypt-gid=&amp;lt;kbag&amp;gt;This is the decrypted kbag (aka dkbag). We can now use it to decrypt iBSS :img4 -i iBSS.*.RELEASE.im4p -o ibss.raw -k &amp;lt;dkbag&amp;gt; Then patch it with kairos :kairos ibss.raw ibss.pwnAnd pack it back to im4p :img4 -i ibss.pwn -o ibss.im4p.pwn -A -T ibss Note that unlinke the dualboot process, a verbose restore doesn’t need boot components to be signed ! In fact, you MUSN’T sign them ! Because idevicerestore will do this for you.But when booting a ramdisk manually, you must send components that are already signed.Do the same with iBEC, but don’t forget to add the verbose flag : kairos ibss.raw ibss.pwn -b &quot;-v&quot;Finally, replace the original files in Firmware/dfu with these.Patching the KernelThe procedure is exactly the same as what’s described in the dualboot guide here.That’s because we just need to patch AMFI, no need for anything fancier than that.Here are the instructions :img4 -i kernelcache.release.* -o kcache.rawKernel64Patcher kcache.raw kcache.patched -absdiff kcache.raw kcache.patched kc.patchimg4 -i kernelcache.release.* -o kcache.im4p.pwn -T rkrn -P kc.bpatch Note that we need to add the rkrn tag to specify our kernel is a restore kernel.You can find a complete list of all possible tags here.Finally, replace the kernel inside the IPSW with your patched one.Patching the ramdiskFirst, let’s prepare the ramdisk to access its content.img4 -i &amp;lt;update-ramdisk&amp;gt; -o ramdisk.dmgThen mount the ramdisk (either double-click on the dmg, or use hdiutil).Patching UI routinesThat is the whole point of what we want to do : disable UI routines.First, load /usr/local/bin/restored-update in Hopper and search for a function called ramrod_display (as @nyan_satan describes here).Locate the _ramrod_display_set_progress functionA function of interest here is _ramrod_display_set_progress which calls ramrod_display_set_granular_progress_forced.The latter function seems to effectively perform the display-related operations, so we will disable calls to this function.To do this, replace the branch operation in _ramrod_display_set_progress by a return instruction, as follows :Branch instruction is replaced by a retFinally, follow my other blog post about Patching an executable with Python to apply this patch without a complete Hopper license. The method is strictly the same, and you shouldn’t have much trouble adapting this post to your case.Once our patch is applied, we musn’t forget to fakesign the binary and restore its entitlements :ldid2 -e restored_update &amp;gt; restored_plist.entspatcher.py restored_update #This applies the patchmv restored_update_patched restored_updatechmod 755 restored_updateldid2 -Srestored_plist.ents restored_updatePatching asrAs shown in the corresponding page on The iPhone Wiki, /usr/sbin/asr performs a check that we need to patch.While we could do this by hand, @md has written a convenient program which does this automatically : asr64_patcherAnd of course, we mustn’t forget neither about entitlements and fakesign.asr64_patcher asr asr_patchedldid2 -e asr &amp;gt; asr_ents.plistldid2 -S asr_ents.plist asr_patchedmv asr_patched asrPacking back the ramdiskAll operations on the ramdisk are now done, let’s pack it back for restore :hdiutil detach /Volumes/*.arm64*RamDisk #Optionnal : unmount your ramdiskimg4 -i ramdisk.dmg -o &amp;lt;update-ramdisk-name&amp;gt;.dmg -A -T rdskAgain, replace the ramdisk inside the IPSW with the one we just generated.Packing back the IPSWBe careful not to zip the folder containing your files, but the files themselves !In the Finder, select all files, then right-click &amp;gt; CompressIf you want to do this programmatically (inside a script for example), do the following :cd &amp;lt;the folder&amp;gt;zip -r &amp;lt;output-path&amp;gt;/custom.ipsw *The idea is that must be inside the folder already and zip all files next to you. If not, you will also zip the path to your files and that will corrupt your IPSW.Preparing your deviceNow we need to prepare our device to accept our custom IPSW.While using ipwndfu is indeed the solution, here are the detailed steps.First, prepare a “normal” combo of iBSS + iBEC that you would use for verbose booting.In fact, they are exactly the same as what we generated earlier, but these DO NEED to be signed with an IM4M blob !img4 -i ibss.pwn -o ibss.im4p.pwn -A -T ibss -M IM4MOnce they are ready, exploit your device with ./ipwndfu -p.Then, remove sigchecks (python rmsigchks.py).Finally, send iBSS and iBEC :irecovery -f ibssirecovery -f ibecThe device is now in pwnRecovery, and can still accept unsigned images.RestoringIt’s the most trivial part of the job :idevicerestore custom.ipsw With this command, idevicerestore only performs an “update” restore and thus, uses the Update ramdisk.Specifying the --erase flag will make it use the Erase ramdisk.If you did everything carefully and correctly, you will see the complete restore log right on your device’s screen !I’ve successfully done a verbose restore on my iPhone 5s.I followed @nyan_satan’s blog post to disable the graphical interface, and then modified the Update Ramdisk to load it with checkm8 pic.twitter.com/WDmWTMequb&amp;mdash; MachXNU (@MachXNU) April 30, 2022ConclusionI tried to be as clear and explanatory as possible. However, if you’re still having trouble, feel free to contact me on Twitter or Telegram and I’ll do my best to help you !And if you are thinking “Bruh, what a spoon-feeding tutorial for noobs”, remember that you’ve once been a noob too, and explanations are never useless ! Before knowing somehing by heart, you had to learn it and my goal is to make this learning easier and faster !" }, { "title": "Patch an executable with Python", "url": "/posts/patch-an-executable-with-Python/", "categories": "", "tags": "", "date": "2022-04-24 15:00:00 +0200", "snippet": "Hopper is a very useful disassembler for Mac/Linux and I use it all the time when I need to reverse a binary.The problem is that it costs a whole 99€ to get a license and be able to export a patched binary.In this post, I will show how to apply patches to a binary thanks to Python.Note that this method can also be adapted to any programming language, such as C or others. It can also be used to automate patches if needed.Find something to patchLet’s use a simple example.Consider the following code :#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;int main(){ int age=0; printf(&quot;How old are you ? &quot;); scanf(&quot;%d&quot;, &amp;amp;age); if (age&amp;lt;18){ printf(&quot;You are a child\\n&quot;); } else { printf(&quot;You are an adult\\n&quot;); } return 0;}Assume you are given only the compiled binary, but you are only 10 y.o.We will patch the binary so that it displays You are an adult even if you are too young.Find what patches to apply with HopperLoad the compiled binary in Hopper and navigate to its main function.It should be easy to see that there is an if instruction which redirects execution if you are an adult.The strings are displayed, but too far on the right to be visible hereWe must patch the jump to redirect execution to the second bloc regardless of the result of the test before.The solution is to replace the conditional jump b.le by an unconditionnal jump b.To do this, go to Modify &amp;gt; Assemble instruction... or use the keyboard shortcut Option + A and type the new instruction (adapt it if necessary with the correct name of the bloc) : b loc_100003f18As you can see after patching, the “child” region is never executed, and the execution flow will directly jump to the “adult” bloc.Now, the first thing you need to note down is the offset from the beginning of your binary.It is the offset from the binary’s base 0x100000000 to your instruction.To double check what the base is, navigate to the Mach-O header :This is the Mach-O headerFor us, the offset will be 0x100003f04 - 0x100000000 = 0x3f04Next, we need to find what the new instruction is like in binary code.Select the instruction in the ASM view and switch to hexadecimal view.Make sure you have selected the patched instruction You will see values in red, these are the new hex values for the patched instruction.The patched instruction has its hex representation in redNote them down as well, as we will need them later on.The Hopper part is done, so make sure you got the offset and the hex representation of the instruction.Write a Python script and apply patchesI have provided the script, just after this text.As you can see, we are first loading the original binary in binary mode. This gives us a &amp;lt;bytes&amp;gt; object. Since &amp;lt;bytes&amp;gt; objects are immutable, we need to convert it to a (mutable) array.Once this is done, we simply replace the value at the offset by the new hex representation.That is why we needed both values.Here is the script :#!/usr/bin/python3import sys if len(sys.argv) != 2: print(&#39;Please input path to the binary you want to patch.&#39;) sys.exit()def replace(content, offset, instruction): print(&quot;[i] Replacing instruction at offset&quot;, hex(offset)) content[offset : offset+len(instruction)] = instructiondef bytes_to_array(input): n = len(input) L = [b&#39;\\x00&#39;]*n for i in range(n): L[i] = input[i] return Lorig_file = sys.argv[1]patched_file = orig_file + &#39;_patched&#39;file = open(orig_file, &#39;rb&#39;)content = bytes_to_array(file.read())file.close()replace(content, 0x3f04, b&#39;\\x05\\x00\\x00\\x14&#39;) # replace if necessaryfile = open(patched_file, &#39;wb&#39;)file.write(bytes(content))file.close()print(&quot;Patched file created&quot;)Then, patch the executable :./patcher.py &amp;lt;path-to-executable&amp;gt;The produced binary is called &amp;lt;original_name_patched&amp;gt; and can be found at the same path than the original file.What you have to do next is configure your system to execute this patched binary. Many systems include protections against this type of attack, and iOS or macOS are no exceptions to this.See my other blog article about running patched executables on macOS to effectively run this patched executable on your machine ! However, as a spoiler, I can already show you that our patch worked :Wow, society is moving at a fast pace !ConclusionTo summarize, you can use Hopper to see what/where patches should be applied and see what the new instructions will look like after the patch.Then, a simple script (which can of course be adapted to any language) applies the patches and produces the patched executable.Finally, you have to configure your system to run this patched executable, but this is too OS-specific to be discussed here." }, { "title": "Run a patched executable on macOS", "url": "/posts/run-a-patched-executable-on-macOS/", "categories": "", "tags": "", "date": "2022-04-24 12:00:00 +0200", "snippet": "IntroductionIn the previous article, we discussed how to patch an executable to redirect execution flow.The problem is that if you try to run this on your Mac right after patching, the system will refuse to execute it : zsh killedDon’t forget to add executable permissions first with chmod +x ./age though.Afterwards, you get :$ ./patcher.py ./age[i] Replacing instruction at offset 0x3f04Patched file created$ chmod +x ./age$ ./age_patchedzsh: killed ./age_patchedIdentifying the problemIt is pretty straightforward, and after having a look at the Console app, we can see that the problem comes from the executable’s signature.Just to be sure, we can run :$ codesign -v ./age_patched ./age_patched: invalid signature (code or signature have been modified)In architecture: arm64Creating a code signing certificateWe have to re-sign our executable, but first we must create a code signing certificate for that.This procedure has been described countless times online to sign gdb on macOS, so if you have trouble with this step, there are plenty of alternative tutorials available.\\ Open Keychain.app, go to Certificate Assistant &amp;gt; Create a certificate... Select Self-Signed Root, Code Signing Unlock System keychain Move the certificate from Login to SystemIf you have trouble doing this, try a copy/paste + delete original Right click on your certificate, Get info and expand the Trust triangle. In the drop-down menu, choose Always trust Close the window and authenticate.If you’ve done everything correctly, there is a + sign next to your certificate. Our certificate is ready to use !Signing the patched executableNow you can sign your patched executable :$ codesign -fs MachXNU ./age_patched./age_patched: replacing existing signatureYou can now execute the (patched and) signed binary :$ ./age_patched How old are you ? 10You are an adultConclusionCreating a code signing certificate and signing the patched binary is enough to make macOS execute it !" } ]
